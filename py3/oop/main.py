"""
class Item:
    # function in a class are called methods
    # self is an argument autogenerated
    # python passes the object itself as a first
    # argument
    # if we don't put self argument to the method
    # python will throw exception method_name() takes 0 positional arguments
    # but 1 was given because it always passes the object itself
    def calculateTotalPrice(self, x, y):
        return x * y


item1 = Item()
item1.name = "Phone"
item1.price = 100
item1.quantity = 5
# calling this method
# when you call a method
# python passes the object itself as the first argument everytime
print(item1.calculateTotalPrice(item1.price, item1.quantity))

item2 = Item()
item2.name = "Laptop"
item2.price = 1000
item2.quantity = 3
print(item2.calculateTotalPrice(item2.price, item2.quantity))
"""

# CONSTRUCTOR
"""
class Item:
    def __init__(self, name="Arid", price=-1, quantity=-1):
        self.name = name
        self.price = price
        self.quantity = quantity

    def calculateTotalPrice(self):
        return self.price * self.quantity


item1 = Item("Phone", 100, 10)
item2 = Item("Laptop", 1000, 4)
item2.hasNumPad = False
print(item1.calculateTotalPrice())
print(item2.calculateTotalPrice())

#
item3 = Item(name="Arid", price=100, quantity=3)
print(item3.calculateTotalPrice())

"""

# STRICT TYPES AND ASSERT

"""
class Item:

    def __init__(self, name: str, price: float, quantity: int):
        # Run validation to the received arguments
        assert price >= 0, f'Price {price} is not greater than zero'
        assert quantity >= 0 ,f'Quantity {price} is not greater than zero'
        # Assign to self object
        self.name = name
        self.price = price
        self.quantity = quantity

    def calculateTotalPrice(self):
        return self.price * self.quantity


item = Item("Arid on", 2.0, 1)
print(item.calculateTotalPrice())


"""


class Item:
    payRate = 0.8  # The pay rate after 20 % discount
    all = []

    def __init__(self, name: str, price: float, quantity: int):
        # Run validation to the received arguments
        assert price >= 0, f'Price {price} is not greater than zero'
        assert quantity >= 0, f'Quantity {price} is not greater than zero'
        # Assign to self object
        self.name = name
        self.price = price
        self.quantity = quantity

        # Actions to execute
        Item.all.append(self)

    def calculateTotalPrice(self):
        return self.price * self.quantity

    def applyDiscount(self):
        self.price = self.price * Item.payRate

    def __repr__(self):
        return f"Item('{self.name}' , {self.price} , {self.quantity})"


item = Item("Arid on", 2.0, 1)
print(Item.__dict__)  # bring all the attributes that belong to the class level
print(item.__dict__)  # bring all the attributes to the object

attributes = item.__dict__
for i in attributes:
    print(f"Attribute name {i} , default value : {attributes.get(i)}")

#####
item1 = Item('Arid on', 2.1, 1)
item1.applyDiscount()
# print(item1.price)

####
item2 = Item("Laptop", 1000, 3)
# This will not change anything because the payRate attribute
# in applyDiscount() method is called by Class Item not the object
# it will change the discount if we call it with self object
# self.price = self.price * self.payRate

item2.payRate = 0.7
item2.applyDiscount()
# print(item2.price)

for obj in Item.all:
    print(obj.name)
